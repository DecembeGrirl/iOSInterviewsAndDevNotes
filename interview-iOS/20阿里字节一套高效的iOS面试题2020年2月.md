# 阿里字节一套高效的iOS面试题2020年2月

> 作者：Monkery&&juejin.im/post/5e397ccaf265da570b3f1b02

> 目前此Repo 为东半球解答最完整的一份

- 笔者最近收集梳理了一些iOS相关的问题，其中大部分都是大厂面试或者面试其他人用到的，能命中大部分的面试和日常工作，更希望你可以用它来检验自己

- 此篇问题，有一部分和之前的部分题目有很多重合，类似的，可以借鉴参考。



## runtime相关问题

>  runtime是iOS开发最核心的知识了，如果下面的问题都解决了，那么对runtime的理解已经很深了。 runtime已经开源了，官网[objc4](https://opensource.apple.com/tarballs/objc4/)


### 结构模型

### 介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）

<details>
<summary> 参考内容 </summary>

- 对象：OC中的对象指向的是一个objc_object指针类型，typedef struct objc_object *id;从它的结构体中可以看出，它包括一个isa指针，指向的是这个对象的类对象,一个对象实例就是通过这个isa找到它自己的Class，而这个Class中存储的就是这个实例的方法列表、属性列表、成员变量列表等相关信息的。
- 类：在OC中的类是用Class来表示的，实际上它指向的是一个objc_class的指针类型，typedef struct objc_class *Class
- OC的Class类型包括如下数据（即：元数据metadata）：super_class（父类类对象）；name（类对象的名称）；version、info（版本和相关信息）；instance_size（实例内存大小）；ivars（实例变量列表）；methodLists（方法列表）；cache（缓存）；protocols（实现的协议列表）;
- 当然也包括一个isa指针，这说明Class也是一个对象类型，所以我们称之为类对象，这里的isa指向的是元类对象（metaclass），元类中保存了创建类对象（Class）的类方法的全部信息。

- OC对象、类、元类之间的关系

![参考图示](https://ucc.alicdn.com/pic/developer-ecology/d237d2810b0442f4a697f5bcf0707980.png)

</details>

### 为什么要设计metaclass

* 类对象、元类对象能够复用消息发送流程机制；
* 单一职责原则

###  class_copyIvarList & class_copyPropertyList区别

<details>
<summary> 参考内容 </summary>

>  property 正常使用会生成对应的实例变量，所以 `Ivar` 可以查到。

- class_copyIvarList 获取类对象中的所有实例变量信息，从 `class_ro_t` 中获取：

- class_copyPropertyList 获取类对象中的属性信息， class_rw_t 的 properties，先后输出了 category / extension/ baseClass 的属性，而且仅输出当前的类的属性信息，而不会向上去找 superClass 中定义的属性。
-  可参考如下代码

```
Ivar *
class_copyIvarList(Class cls, unsigned int *outCount)
{
    const ivar_list_t *ivars;
    Ivar *result = nil;
    unsigned int count = 0;

    if (!cls) {
        if (outCount) *outCount = 0;
        return nil;
    }

    mutex_locker_t lock(runtimeLock);

    assert(cls->isRealized());
    
    if ((ivars = cls->data()->ro->ivars)  &&  ivars->count) {
        result = (Ivar *)malloc((ivars->count+1) * sizeof(Ivar));
        
        for (auto& ivar : *ivars) {
            if (!ivar.offset) continue;  // anonymous bitfield
            result[count++] = &ivar;
        }
        result[count] = nil;
    }
    
    if (outCount) *outCount = count;
    return result;
}

objc_property_t *
class_copyPropertyList(Class cls, unsigned int *outCount)
{
    if (!cls) {
        if (outCount) *outCount = 0;
        return nil;
    }

    mutex_locker_t lock(runtimeLock);

    checkIsKnownClass(cls);
    assert(cls->isRealized());
    
    auto rw = cls->data();

    property_t **result = nil;
    unsigned int count = rw->properties.count();
    if (count > 0) {
        result = (property_t **)malloc((count + 1) * sizeof(property_t *));

        count = 0;
        for (auto& prop : rw->properties) {
            result[count++] = &prop;
        }
        result[count] = nil;
    }

    if (outCount) *outCount = count;
    return (objc_property_t *)result;
}
```

### class_rw_t 和 class_ro_t 的区别

- class_rw_t 
	-  class_ro_t
	-  Protocols
	-  MethodLists
	-  Properties

- class_rw_t 中的 properties 属性按顺序包含分类/扩展/基类中的属性。

```
struct class_ro_t {
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;
    
    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};

struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;

#if SUPPORT_INDEXED_ISA
    uint32_t index;
#endif
}

```
</details>

### category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序

<details>
<summary> 参考内容 </summary>

- +load 方法是 images 加载的时候调用，假设有一个 XXXClass 类，其主类和所有分类的 `+load` 都会被调用，**优先级是先调用主类**，且如果主类有继承链，那么加载顺序还必须是基类的 `+load` ，接着是父类，最后是子类；category 的 `+load` 则是按照**编译顺序**来的，先编译的先调用，后编译的后调用，可在 Xcode  的 BuildPhase 中查看
	- 分类添加到了 `rw = cls->data()` 中的 `methods/properties/protocols` 中，实际上并无`覆盖`，只是查找到就返回了，导致本类函数无法加载。

</details>

### initialize && Load

<details>
<summary> 参考内容 </summary>

- **类第一次被使用到的时候会被调用**，底层实现有个逻辑先判断父类是否被初始化过，没有则先调用父类，然后在调用当前类的 initialize 方法.
	- 一个类 A 存在多个 category ，且 category中各自实现了 initialize 方法，这时候走的是 **消息发送流程**，**也就说 initialize 方法只会调用一次，也就是最后编译的那个category中的 initialize 方法。**

- 如果+load 方法中调用了其他类：比如 B 的某个方法，其实就是走消息发送流程，由于 B 没有初始化过，则会调用其 initialize 方法，但此刻 B 的 +load 方法可能还没有被系统调用过。

#####  不管是 load 还是 initialize 方法都是 runtime 底层自动调用的，如果开发自己手动进行了 `[super load]` 或者 `[super initialize]` 方法，实际上是走消息发送流程，那么这里也涉及了一个调用流程，需要引起注意。

</details>

### category & extension区别，能给NSObject添加Extension吗，结果如何

- 不可以为系统类添加扩展

### 在方法调用的时候，方法查询-> 动态解析-> 消息转发 之前做了什么

<details>
<summary> 参考内容 </summary>

- OC中的方法调用，编译后的代码最终都会转成 `objc_msgSend(id , SEL, ...)` 方法进行调用，
- 这个方法第一个参数是一个消息接收者对象，runtime通过这个对象的isa指针找到这个对象的类对象，从类对象中的cache中查找(**哈希查找，bucket 桶实现**)是否存在SEL对应的IMP，若不存在，则会在 method_list中查找（二分查找或者顺序查找），如果还是没找到，则会到supper_class中查找，仍然没找到的话，就会调用_objc_msgForward(id, SEL, ...)进行消息转发。

</details>

### IMP、SEL、Method的区别和使用场景
<details>
<summary> 参考内容 </summary>

- [面试题第三份基础概念参考](03interview-iOS-3.md)

```
typedef struct method_t *Method;

using MethodListIMP = IMP;

struct method_t {
    SEL name;
    const char *types;
    MethodListIMP imp;
};
```
</details>

### load、initialize方法的区别什么？在继承关系中他们有什么区别

<details>
<summary> 参考内容 </summary>

> 程序启动 -> load(自动调用) -> [XXAudioTool loadData] ->initialize(自动调用) ->loadData

- load 方法调用时机，而且只调用当前类本身，不会调用superClass 的 `+load` 方法：
	- 和load不同，即使子类不实现initialize方法，会把父类的实现继承过来调用一遍。注意的是在此之前，父类的方法已经被执行过一次了，同样不需要super调用。
-  ` callInitialize(cls)` 然后又调用了 `lockAndFinishInitializing(cls, supercls)`。 
</details>

### 说说消息转发机制的优劣
<details>
<summary> 参考内容 </summary>

- 消息转发
	- 消息转发机制（可以间接实现多重继承）
	- methodSignatureForSelector:的处理使得NSNull对象可以接受任何 selector 而不产生doesNotRecognizeSelector:异常
	- forwardInvocation:的处理使得NSNull实例接受到 unknown selector 时，不做任何处理，即空操作

- 动态方法解析	
</details>


### 内存管理

###  weak的实现原理？SideTable的结构是什么样的

- [weak修饰的释放则自动被置为nil的实现原理](./02interview-iOS-2.md)
- [weak弱引用的代码逻辑实现?](./03interview-iOS-3.md)

<details>
<summary> SideTable参考内容 </summary>

- SideTable 结构体在 runtime 底层用于引用计数和弱引用关联表，其数据结构是这样：
	- 指向某个对象A的所有  weak 关键字修饰的引用都 append 到 `weak_entry_t` 结构体中的`referrers`， 同时`weak_entry_t` 的 `referent` 就是对象A，之后在dealloc 释放时遍历 `weak_table` 遍历时会判断 referent 是否为对象 A 取到 `weak_entry_t`，加入到该 SideTable 中 `weak_table` 中：

```c++
struct SideTable {

    spinlock_t slock;

    RefcountMap refcnts;

    weak_table_t weak_table;
}

struct weak_table_t {
    // 保存了所有指向指定对象的 weak 指针
    weak_entry_t *weak_entries;
    // 存储空间
    size_t    num_entries;
    // 参与判断引用计数辅助量
    uintptr_t mask;
    // hash key 最大偏移值
    uintptr_t max_hash_displacement;
};

```

```

id objc_initWeakOrNil(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak<DontHaveOld, DoHaveNew, DontCrashIfDeallocating>
        (location, (objc_object*)newObj);
}
```
</details>

###  关联对象的应用？系统如何实现关联对象的

> [应用实例代码：为UIView及子类新增点击事件Block回调处理](https://github.com/DevDragonLi/iOSDevDemo/blob/master/1-DevDemo/PodPrivate_demo/Pods/JueJinBasedComponent/JueJinBasedComponent/Classes/UIKit/UIView/UIView%2BXTHelper.m)

- [本系列面试题第八份参考：关联对象](08字节跳动面试题：2018年4月.md)

<details>
<summary> SideTable参考内容 </summary>

- 置空关联对象：赋值给与nil即可

```c++
id _object_get_associative_reference(id object, void *key) {
    id value = nil;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        // manager.associations()  `AssociationsHashMap` 对象(*_map)
        AssociationsHashMap &associations(manager.associations());
        // intptr_t 是为了兼容平台，在64位的机器上，intptr_t和uintptr_t分别是long int、unsigned long int的别名；在32位的机器上，intptr_t和uintptr_t分别是int、unsigned int的别名
        // DISGUISE 内部对指针做了 ~ 取反操作
        disguised_ptr_t disguised_object = DISGUISE(object);
        /*
         AssociationsHashMap 继承自 unordered_map，存储 key-value 的组合
         iterator find ( const key_type& key )，如果 key 存在，则返回key对象的迭代器，
         如果key不存在，则find返回 unordered_map::end；因此可以通过 `map.find(key) == map.end()`
         判断 key 是否存在于当前 map 中。
         */
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        if (i != associations.end()) {
            /*
                unordered_map 的键值分别是迭代器的first和second属性。
                所以说上面先通过 object 对象(实例对象or类对象) 找到其所有关联对象
                i->second 取到又是一个 ObjectAssociationMap
                此刻再通过我们自己设定的 key 来查找对应的关联属性值，不过使用
                `ObjcAssociation` 封装的
             */
            ObjectAssociationMap *refs = i->second;
            ObjectAssociationMap::iterator j = refs->find(key);
            if (j != refs->end()) {
                ObjcAssociation &entry = j->second;
                value = entry.value();
                policy = entry.policy();
                // 平常 OBJC_ASSOCIATION_RETAIN = 01401
                // OBJC_ASSOCIATION_GETTER_RETAIN = (1 << 8)
                if (policy & OBJC_ASSOCIATION_GETTER_RETAIN) {

                    objc_retain(value);
                }
            }
        }
    }
    if (value && (policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        objc_autorelease(value);
    }
    return value;
}


void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // retain the new value (if any) outside the lock.
    ObjcAssociation old_association(0, nil);
    // 如果value对象存在，则进行retain or copy 操作
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        // manager.associations()  `AssociationsHashMap` 对象(*_map)
        AssociationsHashMap &associations(manager.associations());
        // intptr_t 是为了兼容平台，在64位的机器上，intptr_t和uintptr_t分别是long int、unsigned long int的别名；在32位的机器上，intptr_t和uintptr_t分别是int、unsigned int的别名
        // DISGUISE 内部对指针做了 ~ 取反操作
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            /*
             AssociationsHashMap 继承自 unordered_map，存储 key-value 的组合
             iterator find ( const key_type& key )，如果 key 存在，则返回key对象的迭代器，
             如果key不存在，则find返回 unordered_map::end；因此可以通过 `map.find(key) == map.end()`
             判断 key 是否存在于当前 map 中。
             */
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            // 这里和get操作不同，set操作时如果查询到对象没有关联对象，那么这一次设值是第一次，
            // 所以会创建一个新的 ObjectAssociationMap 用来存储实例对象的所有关联属性
            if (i != associations.end()) {
                // secondary table exists
                /*
                    unordered_map 的键值分别是迭代器的first和second属性。
                    所以说上面先通过 object 对象(实例对象or类对象) 找到其所有关联对象
                    i->second 取到又是一个 ObjectAssociationMap
                    此刻再通过我们自己设定的 key 来查找对应的关联属性值，不过使用
                    `ObjcAssociation` 封装的
                 */
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                // 关联属性用 ObjcAssociation 结构体封装
                if (j != refs->end()) {
                    old_association = j->second;
                    j->second = ObjcAssociation(policy, new_value);
                } else {
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                // 知识点是：newisa.has_assoc = true;
                object->setHasAssociatedObjects();
            }
        } else {
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    if (old_association.hasValue()) ReleaseValue()(old_association);
}

```
</details>

###  关联对象的如何进行内存管理的？关联对象如何实现weak属性

<details>
<summary> 参考内容 </summary>

- 使用了 `policy` 设置内存管理策略
	- OBJC_ASSOCIATION_ASSIGN类型的关联对象和`weak`有一定差别，而更加接近于`unsafe_unretained`，即当目标对象遭到摧毁时，属性值不会自动清空。

- 然后内部封装一个 `weak` 变量持有；或者不用 weak，但是还是封装一层，但是在 dealloc 中进行置为 nil操作

</details>

###  Autoreleasepool的原理？所使用的的数据结构是什么

<details>
<summary> 参考内容 </summary>

- 基于栈为节点（node）的双向链表
- 使用 `@autoreleasePool` 包裹的作用域中，所有调用 autorelease 都会将对象push到自动释放池，作用域结束就会drain一次，这里涉及到了 哨兵对象，也就是 插入一个nil标识。

</details>

###  ARC的实现原理？ARC下对retain & release做了哪些优化
- [本系列面试题第三份参考：ARC的实现原理](03interview-iOS-3.md)

###  ARC下哪些情况会造成内存泄漏

<details>
<summary> 参考内容 </summary>

* 循环引用;
* CF类型内存/C语言malloc出来的对象
* 单例也会造成内存泄漏
	* 可以根据项目需求设置为可销毁对象

</details>

## 其他

### Method Swizzle注意事项
<details>
<summary> 参考内容 </summary>

- method_exchangeImplementations  -> method_setImplementation
- 如果直接替换，相当于交换了父类这个方法的实现，但这个新的实现是在子类中的，父类的实例调用这个方法时，会崩溃。建议：class_addMethod

```
AFNetworking 源码涉及代码
static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) {
    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);
    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);
    method_exchangeImplementations(originalMethod, swizzledMethod);
}

static inline BOOL af_addMethod(Class theClass, SEL selector, Method method) {
    return class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));
}

+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass {
    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));
    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));

    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) {
        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));
    }

    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) {
        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));
    }
}

```
</details>


### 属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗
<details>
<summary> 参考内容 </summary>

-   unfair 锁，不能完全保证
-   因为对于容器变量的修改不能保证线程安全，比如 NSMutableArray/NSMutableDictionnary。等

</details>

###  iOS 中内省的几个方法有哪些？内部实现原理是什么
<details>
<summary> 参考内容 </summary>

> 对象在运行时获取其类型的能力称为内省

-  参考下题

```
-(BOOL) isKindOfClass:            判断是否是这个类或者这个类的子类的实例
-(BOOL) isMemberOfClass:      判断是否是这个类的实例
-(BOOL) respondsToSelector:                      判读实例是否有这样方法
+(BOOL) instancesRespondToSelector:      判断类是否有这个方法

```
</details>

### class、objc_getClass、object_getclass 方法有什么区别?

<details>
<summary> 参考内容 </summary>

- object_getClass:获得的是isa的指向
- self.class:当self是实例对象的时候，返回的是类对象，否则则返回自身。
- 类方法class，返回的是self，所以当查找meta class时，需要对类对象调用object_getClass方法

```
/ 返回的 isa 指针指向的对象，如果 obj 是实例，返回的是类对象，如果 obj 是类对象，返回的是元类对象
// 如果是元类对象，返回的是 NSObject 元类对象（所有元类对象的isa指针都指向了 NSObject 元类对象）
Class object_getClass(id obj)
{
   if (obj) return obj->getIsa();
   else return Nil;
}
   
// 通过传入类名称 返回类对象
Class objc_getClass(const char *aClassName)
{
   if (!aClassName) return Nil;
   
   // NO unconnected, YES class handler
   return look_up_class(aClassName, NO, YES);
}
```
</details>

## NSNotification相关

> [gnustep/libs-base](https://github.com/gnustep/libs-base)

### 实现原理（结构设计、通知如何存储的、name&&observer&&SEL之间的关系等）

<details>
<summary> 参考内容 </summary>

- 数据结构关系图

 ![](https://user-gold-cdn.xitu.io/2020/3/4/170a60b8d529127c?imageView2/0/w/600/h/320/)

- 通过name & object 查找到所有的obs对象(保存了observer和sel)，放到数组中
- 通过performSelector：逐一调用sel，这是个同步操作
- 释放notification对象

```
// 根容器，NSNotificationCenter持有
typedef struct NCTbl {
  Observation		*wildcard;	/* 链表结构，保存既没有name也没有object的通知 */
  GSIMapTable		nameless;	/* 存储没有name但是有object的通知	*/
  GSIMapTable		named;		/* 存储带有name的通知，不管有没有object	*/
    ...
} NCTable;

// Observation 存储观察者和响应结构体，基本的存储单元
typedef	struct	Obs {
  id		observer;	/* 观察者，接收通知的对象	*/
  SEL		selector;	/* 响应方法		*/
  struct Obs	*next;		/* Next item in linked list.	*/
  ...
} Observation;

```
</details>

###  通知的发送时同步的，还是异步的

- 同步发送

###  NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息

- NSNotificationQueue 

###  NSNotificationQueue是异步还是同步发送？在哪个线程响应

<details>
<summary> 参考内容 </summary>

> 通知队列，用于异步发送消息，**这个异步并不是开启线程，而是把通知存到双向链表实现的队列里面，等待某个时机触发时调用NSNotificationCenter的发送接口进行发送通知**，这么看NSNotificationQueue
最终还是调用NSNotificationCenter进行消息的分发

- 依赖runloop，所以如果在其他子线程使用NSNotificationQueue，需要开启runloop
- 最终还是通过NSNotificationCenter进行发送通知，所以这个角度讲它还是同步的
- 所谓异步，指的是非实时发送而是在合适的时机发送，并没有开启异步线程

</details>

###  NSNotificationQueue和runloop的关系
<details>
<summary> 参考内容 </summary>

- NSNotificationQueue主要做了两件事：
	- 添加通知到队列
	- 删除通知
</details>

###  如何保证通知接收的线程在主线程

<details>
<summary> 参考内容 </summary>

- 使用addObserverForName: object: queue: usingBlock方法注册通知，指定在mainqueue上响应block
- 在主线程注册一个machPort，它是用来做线程通信的，当在异步线程收到通知，然后给machPort发送消息，这样肯定是在主线程处理的，具体用法去网上资料很多，苹果官网也有

</details>

###  页面销毁时不移除通知会崩溃吗

<details>
<summary> 参考内容 </summary>

- 有时候会导致crash

- 比如在你通知事件中处理数据或UI事件，但是由于通知的的不确定性造成处理事件的时间不确定，有异步操作在通知事件中处理等都可能造成崩溃。

</details>

###  多次添加同一个通知会是什么结果？多次移除通知呢

<details>
<summary> 参考内容 </summary>

- 存储过程并没有做去重操作，同一个通知注册多次则响应多次

- 因为查找时做了这个链表的遍历，所以删除时会把重复的通知全都删除掉

</details>


###  下面的方式能接收到通知吗？为什么

```
// 发送通知
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@"TestNotification" object:@1];
// 接收通知
[NSNotificationCenter.defaultCenter postNotificationName:@"TestNotification" object:nil];

```
<details>
<summary> 参考内容 </summary>

- 存储是以name和object为维度的，**即判定是不是同一个通知要从name和object区分，如果他们都相同则认为是同一个通知**，后面包括查找逻辑、删除逻辑都是以这两个为维度的
- 故而不会。

</details>

## runloop

### app如何接收到触摸事件的
<details>
<summary> 参考内容 </summary>

- 系统响应阶段 (SpringBoad.app 是一个系统进程，可以理解为桌面系统，可以统一管理和分发系统接收到的触摸事件。)
	- 指触碰屏幕，屏幕感应到触碰后，将事件交由IOKit处理。
	- IOKit将触摸事件封装成一个IOHIDEvent对象，并通过mach port传递给SpringBoad进程。
	- SpringBoard进程因接收到触摸事件，将触摸事件交给前台app进程来处理。

- APP响应阶段
	- APP进程的mach port接受到SpringBoard进程传递来的触摸事件，主线程的runloop被唤醒，触发了source1回调。
	- source1回调又触发了一个source0回调，将接收到的IOHIDEvent对象封装成UIEvent对象，此时APP将正式开始对于触摸事件的响应。
	- source0回调内部将触摸事件添加到UIApplication对象的事件队列中。事件出队后，UIApplication开始一个寻找最佳响应者的过程，这个过程又称hit-testing，另外，此处开始便是与我们平时开发相关的工作了。
	- 寻找到最佳响应者后，接下来的事情便是事件在响应链中的传递及响应了。
	- 触摸事件历经坎坷后要么被某个响应对象捕获后释放，要么致死也没能找到能够响应的对象，最终释放。至此，这个触摸事件的使命就算终结了。runloop若没有其他事件需要处理，也将重归于眠，等待新的事件到来后唤醒。
- [应用接收触摸事件后如何寻找最佳响应者](./08字节跳动面试题：2018年4月.md)

</details>

###  为什么只有主线程的runloop是开启的
<details>
<summary> 参考内容 </summary>

- 主线程需要维持一份RunLoop，保持App在Main后不会直接退出。

- 其他线程默认并没有调用 `NSRunLoop *runloop = [NSRunLoop currentRunLoop]`

```c
CFRunLoopRef CFRunLoopGetCurrent(void) {
    CHECK_FOR_FORK();
    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);
    if (rl) return rl;
    return _CFRunLoopGet0(pthread_self());
}
```
</details>

###  为什么只在主线程刷新UI
<details>
<summary> 参考内容 </summary>

- UIKit并不是一个 **线程安全** 的类，UI操作涉及到渲染访问各种View对象的属性
- **如果异步操作下会存在读写问题，而为其加锁则会耗费大量资源并拖慢运行速度**
- 另一方面因为整个程序的起点`UIApplication`是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以 view 只能在主线程上才能对事件进行响应。而在渲染方面由于图像的渲染需要以60帧的刷新率在屏幕上 **同时** 更新，在非主线程异步化的情况下无法确定这个处理过程能够实现同步更新。

</details>

###  PerformSelector和runloop的关系
<details>
<summary> 参考内容 </summary>

- perform 有几种方式，如 [self performSelector:@selector(perform) withObject:nil] 同步执行的，等同于 objc_msgSend 方法执行调用方法。

- [self performSelector:@selector(perform) withObject:nil afterDelay:0] 则是会在当前 runloop 中起一个 timer，如果当前线程没有起runloop(也就是上面说的没有调用 [NSRunLoop currentRunLoop]` 方法的话)，则不会有输出

</details>

###  如何使线程保活

<details>
<summary> 参考内容 </summary>

> 线程保活就是不让线程退出，所以往简单说就是搞个 “while(1)” 自己实现一套处理流程，事件派发就可以了。

- runloop 线程保活前提就是有事情要处理，这里指 timer，source0，source1 事件。

- Timer && Port 

```
NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
   NSLog(@"timer 定时任务");
}];
NSRunLoop *runloop = [NSRunLoop currentRunLoop];
[runloop addTimer:timer forMode:NSDefaultRunLoopMode];
[runloop run];

```

```
NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
[runLoop run];

```
</details>

## KVO

### 实现原理
- [参考本系列面试题第八份相关部分](./08字节跳动面试题：2018年4月.md#KVO内部实现原理（多家公司有问到）)

### 如何手动关闭KVO
<details>
<summary> 参考内容 </summary>

```
+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {
    if ([key isEqualToString:@"closeType"]) {
        return NO;
    }else{
        return [super automaticallyNotifiesObserversForKey:key];
    }
}

-(void)setProperty:(NSString *)Property{
    
    if (_Property!=Property) {
  
        [self willChangeValueForKey:@"Property"];
        _Property=Property;
        [self didChangeValueForKey:@"Property"];
    }
    
}
```
</details>

### 通过KVC修改属性会触发KVO么
<details>
<summary> 参考内容 </summary>

> 会触发 KVO 操作，KVC 时候会先查询对应的 getter 和 setter 方法。

```
如果返回 YES，那么可以直接修改实例变量。
+ (BOOL)accessInstanceVariablesDirectly {
    return NO;
}

```

-  KVC 调用 getter 流程：`getKEY，KEY，isKEY, _KEY`，接着是实例变量 `_KEY,_isKEY, KEY, isKEY`;

-  KVC 调用 setter 流程：`setKEY`和 `_setKEY`，实例变量顺序 `_KEY,_isKEY, KEY, isKEY`，没找到就调用 `setValue: forUndefinedKey:`

</details>

### 哪些情况下使用kvo会崩溃，怎么防护崩溃

<details>
<summary> 参考内容 </summary>

- dealloc 没有移除 kvo 观察者，解决方案：创建一个中间对象，将其作为某个属性的观察者，然后dealloc的时候去做移除观察者，而调用者是持有中间对象的，调用者释放了，中间对象也释放了，dealloc 也就移除观察者了；
-  多次重复移除同一个属性，移除了未注册的观察者
-  被观察者提前被释放，被观察者在 dealloc 时仍然注册着 KVO，导致崩溃。 例如：被观察者是局部变量的情况（iOS 10 及之前会崩溃） 比如 weak ；
-  添加了观察者，但未实现 `observeValueForKeyPath:ofObject:change:context:`方法，导致崩溃；
-  添加或者移除时 `keypath == nil`，导致崩溃；

</details>

### kvo的优缺点

- [本系列面试题第六份参考答案KVO及KVC优缺点](./06iOS基础问题系列2017年.md)

## Block

### block的内部实现，结构体是什么样的

<details>
<summary> 参考内容 </summary>

```c++

struct __block_impl {
 void *isa;
 int Flags;
 int Reserved;
 void *FuncPtr;
};
   
struct __main_block_impl_0 {
 struct __block_impl impl;
 struct __main_block_desc_0* Desc;
 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
   impl.isa = &_NSConcreteStackBlock;
   impl.Flags = flags;
   impl.FuncPtr = fp;
   Desc = desc;
 }
};

```
</details>

###  block是类吗，有哪些类型
<details>
<summary> 参考内容 </summary>

>  一般，block有三种：_NSConcreteGlobalBlock、_NSConcreteStackBlock、_NSConcreteMallocBlock，根据Block对象创建时所处数据区不同而进行区别。

- 栈上 Block，引用了栈上变量，生命周期由系统控制的，一旦所属作用域结束，就被系统销毁了。
- 堆上 Block，使用 copy 或者 strong（ARC）下就从栈Block 拷贝到堆上。
- 全局 Block，未引用任何栈上变量时就是全局Block;

</details>

###  一个int变量被 __block 修饰与否的区别？block的变量截获

> [本系列面试题相关问题：Block中可以修改全局变量，全局静态变量，局部静态变量吗？](./07深圳iOS面试分享2018年4月.md)
<details>
<summary> 参考内容 </summary>

- 值 copy 和指针 copy，`__block` 修饰的话允许在 block 内部修改变量，因为传入的是 int变量的指针。
-   外部变量有四种类型：自动变量、静态变量、静态全局变量、全局变量。
-    全局变量和静态全局变量在 block 中是直接引用的，不需要通过结构去传入指针；
-    函数/方法中的 static 静态变量是直接在block中保存了指针，如下测试代码：

</details>

###  block在修改NSMutableArray，需不需要添加__block

<details>
<summary> 参考内容 </summary>

> 不需要

-  本身 block 内部就捕获了 NSMutableArray 指针，除非你要修改指针指向的对象，而这里明显只是修改内存数据，这个可以类比 NSMutableString。

</details>

###  怎么进行内存管理的

<details>
<summary> 参考内容 </summary>

>  static void *_Block_copy_internal(const void *arg, const int flags)
>  void _Block_release(void *arg)

- **_NSConcreteGlobalBlock**:是设置在程序的全局数据区域（.data区）中的Block对象。在全局声明实现的block 或者 没有用到自动变量的block为_NSConcreteGlobalBlock，生命周期从创建到应用程序结束。
- _NSConcreteStackBlock是设置在栈上的block对象，生命周期由系统控制的，一旦所属作用域结束，就被系统销毁了。

</details>

###  block可以用strong修饰吗

<details>
<summary> 参考内容 </summary>

-  ARC 是可以的
-  strong 和 copy 的操作都是将栈上block 拷贝到堆上。

</details>

###  解决循环引用时为什么要用__strong、__weak修饰

<details>
<summary> 参考内容 </summary>

- __weak 就是为了避免 retainCycle

- 而block 内部 `__strong` 则是在作用域 retain 持有当前对象做一些操作，结束后会释放掉它。

</details>

###  block发生copy时机

<details>
<summary> 参考内容 </summary>

-  调用Block的copy方法

-  将Block作为函数返回值时

-  将Block赋值给__strong修饰的变量或Block类型成员变量时

-  向Cocoa框架含有usingBlock的方法或者GCD的API传递Block参数时

</details>

###  Block访问对象类型的auto变量时，在ARC和MRC下有什么区别

<details>
<summary> 参考内容 </summary>

- 只要block引用外部局部变量，block就放在堆里面，block使用copy，尽量不要使用strong。

- 只要block引用外部局部变量，block放在栈里面，block只能使用copy不能使用retain，用retain，block还是在栈里面。

</details>

## 多线程

> 主要以GCD为主

### iOS开发中有多少类型的多线程？分别对比

<details>
<summary> 参考内容 </summary>

-  Pthread，较少使用。
-  NSThread，每个 NSThread对象对应一个线程，量级较轻，通常我们会起一个 runloop 保活，然后通过添加自定义source0源或者 perform onThread 来进行调用，优点轻量级，使用简单，缺点：需要自己管理线程的生命周期，保活，另外还会线程同步，加锁、睡眠和唤醒。
- GCD：Grand Central Dispatch（派发） 是基于C语言的框架，可以充分利用多核，是苹果推荐使用的多线程技术
  - 优点：GCD更接近底层，而NSOperationQueue则更高级抽象，所以GCD在追求性能的底层操作来说，是速度最快的，有待确认
  - 缺点：操作之间的事务性，顺序行，依赖关系。GCD需要自己写更多的代码来实现
-  NSOperation 
	-  优点： 使用者的关注点都放在了 operation 上，而不需要线程管理。
	    * 支持在操作对象之间依赖关系，方便控制执行顺序。
	    * 支持可选的完成块，它在操作的主要任务完成后执行。
	    * 支持使用KVO通知监视操作执行状态的变化。
	    * 支持设定操作的优先级，从而影响它们的相对执行顺序。
	    * 支持取消操作，允许您在操作执行时暂停操作。
	- 缺点：高级抽象，性能方面相较 GCD 来说不足一些;

</details>

###  GCD有哪些队列，默认提供哪些队列

<details>
<summary> 参考内容 </summary>

-  主队列（main queue ）【串行】
	-  保证所有的任务都在主线程执行，而主线程是唯一用于 UI 更新的线程。此外还用于发送消息给视图或发送通知。
- 四个全局调度队列（high、default、low、background【并发】
	- Apple 的接口也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务
- 自定义队列  
	- 多个任务以串行方式执行，但又不想在主线程中
	- 多个任务以并行方式执行，但不希望队列中有其他系统的任务干扰。

</details>

###  GCD有哪些方法api

<details>
<summary> 参考内容 </summary>

- dispatch_barrier_sync && dispatch_barrier_async 
- dispatch_once
- dispatch_async
- dispatch_apply
- dispatch_group_t 
- [本系列面试题第一份：谈下iOS开发中知道的哪些锁?（dispatch_semaphore部分）](./01一份"有点难"的iOS面试题MrPeak2016年.md)
- ...

###  GCD主线程 & 主队列的关系

<details>
<summary> 参考内容 </summary>

- 队列其实就是一个数据结构体，主队列由于是串行队列，所以入队列中的 task 会逐一派发到主线程中执行；但是其他队列也可能会派发到主线程执行

</details>

###  如何实现同步，有多少方式就说多少

<details>
<summary> 参考内容 </summary>

-  dispatch_sync
-  dispatch_group，
-  dispatch_semaphore
-  NSLock/NSRecursiveLock
-  pthread_mutex_t 互斥锁、递归锁等
-  @synchronized

</details>

###  dispatch_once实现原理

<details>
<summary> 参考内容 </summary>

```c

void dispatch_once(dispatch_once_t *val, dispatch_block_t block)
{
	dispatch_once_f(val, block, _dispatch_Block_invoke(block));
}

void
dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)
{
#if !DISPATCH_ONCE_INLINE_FASTPATH
	if (likely(os_atomic_load(val, acquire) == DLOCK_ONCE_DONE)) {
		return;
	}
#endif // !DISPATCH_ONCE_INLINE_FASTPATH
	return dispatch_once_f_slow(val, ctxt, func);
}

static void
dispatch_once_f_slow(dispatch_once_t *val, void *ctxt, dispatch_function_t func)
{
	_dispatch_once_waiter_t volatile *vval = (_dispatch_once_waiter_t*)val;
	struct _dispatch_once_waiter_s dow = { };
	_dispatch_once_waiter_t tail = &dow, next, tmp;
	dispatch_thread_event_t event;

	if (os_atomic_cmpxchg(vval, NULL, tail, acquire)) {
		dow.dow_thread = _dispatch_tid_self();
		_dispatch_client_callout(ctxt, func);

		next = (_dispatch_once_waiter_t)_dispatch_once_xchg_done(val);
		while (next != tail) {
			tmp = (_dispatch_once_waiter_t)_dispatch_wait_until(next->dow_next);
			event = &next->dow_event;
			next = tmp;
			_dispatch_thread_event_signal(event);
		}
	} else {
		_dispatch_thread_event_init(&dow.dow_event);
		next = *vval;
		for (;;) {
			if (next == DISPATCH_ONCE_DONE) {
				break;
			}
			if (os_atomic_cmpxchgv(vval, next, tail, &next, release)) {
				dow.dow_thread = next->dow_thread;
				dow.dow_next = next;
				if (dow.dow_thread) {
					pthread_priority_t pp = _dispatch_get_priority();
					_dispatch_thread_override_start(dow.dow_thread, pp, val);
				}
				_dispatch_thread_event_wait(&dow.dow_event);
				if (dow.dow_thread) {
					_dispatch_thread_override_end(dow.dow_thread, val);
				}
				break;
			}
		}
		_dispatch_thread_event_destroy(&dow.dow_event);
	}
}

```

</details>

###  什么情况下会死锁

<details>
<summary> 参考内容 </summary>

> 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。

```
- (void)viewDidLoad {
    [super viewDidLoad];
    dispatch_sync(dispatch_get_main_queue(), ^{
     NSLog()
    });
```

</details>

###  有哪些类型的线程锁，分别介绍下作用和使用场景
- [本系列面试题第一份：谈下iOS开发中知道的哪些锁?](./01一份"有点难"的iOS面试题MrPeak2016年.md)
###  NSOperationQueue中的maxConcurrentOperationCount默认值
<details>
<summary> 参考内容 </summary>

> 默认值为 -1

> 默认的最大操作数由NSOperationQueue对象根据当前系统条件动态确定。

</details>

###  NSTimer、CADisplayLink、dispatch_source_t 的优劣

<details>
<summary> 参考内容 </summary>

#### Timer

- **计时不精确**：不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的**RunLoop**和**RunLoop Mode**有关，如果此**RunLoop**正在执行一个连续性的运算，**timer**就会被延时出发。重复性的**timer**遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行。

#### CADisplayLink

> Apple 专门提供的一个类，主要的优势在于他的执行频率是根据设备屏幕的刷新频率来计算的，也即是时间间隔最准确的定时器。用法和 NSTimer 差不多，当然也存在 retainCycle 问题，解决方式同上。

#### 优缺点

- **优点：** 依托于设备屏幕刷新频率触发事件，所以其触发时间上是最准确的。也是最适合做UI不断刷新的事件，过渡相对流畅，无卡顿感。
- **缺点：**
  1. 由于依托于屏幕刷新频率，若果CPU不堪重负而影响了屏幕刷新，那么我们的触发事件也会受到相应影响。
  2. selector触发的时间间隔只能是duration的整倍数
  3. selector事件如果大于其触发间隔就会造成掉帧现象。

#### dispatch_source_t

```
- (void) dispatch_source_t {
dispatch_source_t  timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
    dispatch_source_set_timer(self.timer, dispatch_walltime(NULL,0 * NSEC_PER_SEC), 1 * NSEC_PER_SEC, 0);
    
    dispatch_source_set_event_handler(self.timer, ^{
        NSLog(@"triggered");
    });
}


dispatch_source_cancel(self.disTimer);

```

**注意：**dispatch_source_t 一定要被设置为成员变量，否则将会立即被释放。

- 优缺点

	- **优点：**不受当前runloopMode的影响;
	- **缺点：**虽然不受runloopMode的影响，但是其计时效应仍不是百分之百准确的;

</details>

## 视图&图像相关

###  AutoLayout的原理，性能如何

###  UIView & CALayer的区别

###  事件响应链

###  drawrect & layoutsubviews调用时机

###  UI的刷新原理

###  隐式动画 & 显示动画区别

###  什么是离屏渲染

###  imageName &  imageWithContentsOfFile区别

###  多个相同的图片，会重复加载吗

###  图片是什么时候解码的，如何优化

###  图片渲染怎么优化

###  如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决

## 性能优化

###  如何做启动优化，如何监控

###  如何做卡顿优化，如何监控

###  如何做耗电优化，如何监控

###  如何做网络优化，如何监控

## 开发证书

### 苹果使用证书的目的是什么

<details>
<summary> 参考内容 </summary>

>  在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，场景有如下三种

-  AppStore 下载应用验证，传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。
-  开发 App 时可以直接把开发中的应用安装进手机进行调试。
-   In-House 企业内部分发，可以直接安装企业证书签名后的 APP。
-   AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。

</details>

### AppStore安装app时的认证流程

###  开发者怎么在debug模式下把app安装到设备呢

## 架构设计

> 典型源码的学习

> 只是列出一些iOS比较核心的开源库，这些库包含了很多高质量的思想，源码学习的时候一定要关注每个框架解决的核心问题是什么，还有它们的优缺点，这样才能算真正理解和吸收

1. AFN
1. SDWebImage
1. JSPatch、Aspects(虽然一个不可用、另一个不维护，但是这两个库都很精炼巧妙，很适合学习)
1. Weex/RN, 笔者认为这种前端和客户端紧密联系的库是必须要知道其原理的
1. CTMediator、其他router库，这些都是常见的路由库，开发中基本上都会用到

### 架构设计

1. 手动埋点、自动化埋点、可视化埋点
1. MVC、MVP、MVVM设计模式
1. 常见的设计模式
1. 单例的弊端
1. 常见的路由方案，以及优缺点对比
1. 如果保证项目的稳定性
1. 设计一个图片缓存框架(LRU)
1. 如何设计一个git diff
1. 设计一个线程池？画出你的架构图
1. 你的app架构是什么，有什么优缺点、为什么这么做、怎么改进

### 其他问题

1. PerformSelector & NSInvocation优劣对比
1. oc怎么实现多继承？怎么面向切面[（可以参考Aspects深度解析-iOS面向切面编程）](https://juejin.im/post/5e13c4366fb9a047f42e6406)
1. 哪些bug会导致崩溃，如何防护崩溃
1. 怎么监控崩溃
1. app的启动过程（考察LLVM编译过程、静态链接、动态链接、runtime初始化）
1. 沙盒目录的每个文件夹划分的作用
1. 简述下match-o文件结构

## 系统基础知识

### 进程和线程的区别

<details>
<summary> 参考内容 </summary>

> 定义

- 进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。

- 线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位。

> 一个线程只能属于一个进程，但是一个进程可以拥有多个线程。多线程处理就是允许一个进程中在同一时刻执行多个任务。

- 线程是一种轻量级的进程，与进程相比，线程给操作系统带来侧创建、维护、和管理的负担要轻，意味着线程的代价或开销比较小。

- 线程没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，线程文本包含在他的进程 的文本片段中，进程拥有的所有资源都属于线程。所有的线程共享进程的内存和资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段， 寄存器的内容，栈段又叫运行时段，用来存放所有局部变量和临时变量。

- 父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信。

- 进程内的任何线程都被看做是同位体，且处于相同的级别。不管是哪个线程创建了哪一个线程，进程内的任何线程都可以销毁、挂起、恢复和更改其它线程的优先权。线程也要对进程施加控制，进程中任何线程都可以通过销毁主线程来销毁进程，销毁主线程将导致该进程的销毁，对主线程的修改可能影响所有的线程。

- 子进程不对任何其他子进程施加控制，进程的线程可以对同一进程的其它线程施加控制。子进程不能对父进程施加控制，进程中所有线程都可以对主线程施加控制。

##### 相同点：

- 进程和线程都有ID/寄存器组、状态和优先权、信息块，创建后都可更改自己的属性，都可与父进程共享资源、都不鞥直接访问其他无关进程或线程的资源。
</details>


### HTTPS的握手过程

<details>
<summary> 参考内容 </summary>

> Session ID 缓存和 Session Ticket 里面保存的也是主密钥，而不是会话密钥，这样每次会话复用的时候再用双方的随机数和主密钥导出会话密钥，从而实现每次加密通信的会话密钥不一样，即使一个会话的主密钥泄露了或者被破解了也不会影响到另一个会话。

1. 客户端将TLS版本，支持的加密算法，ClientHello random C 发给服务端【客户端->服务端】
2. 服务端从加密算法中pick一个加密算法， ServerHello random  S，server 证书返回给客户端；【服务端->客户单】
3. 客户端验证 server 证书【客户端】
4. 客户端生成一个 48 字节的预备主密钥，其中前2个字节是 Protocol Version，后46个字节是随机数，客户端用证书中的公钥对预备主密钥进行非对称加密后通过 client key exchange 子消息发给服务端【客户端->服务端】
5. 服务端用私钥解密得到预备主密钥；【服务端】
6. 服务端和客户端都可以通过预备主密钥、ClientHello random C 和  ServerHello random S 通过 PRF 函数生成主密钥；会话密钥由主密钥、SecurityParameters.server_random 和 SecurityParameters.client_random 数通过 PRF 函数来生成会话密钥里面包含对称加密密钥、消息认证和 CBC 模式的初始化向量，对于非 CBC 模式的加密算法来说，就没有用到这个初始化向量。

</details>


### 什么是中间人攻击？怎么预防
<details>
<summary> 参考内容 </summary>

- **中间人拦截客户端消息，然后再发送给服务端；服务端发发送消息给中间人，中间人再返还给客户端。**
- HTTP 明文传输，客户端和服务端进行通信时，中间人即指夹在客户端和服务端之间的第三者，对于客户端来说，中间人就是 **服务端**，对于服务端来说，中间人就是 **客户端**。

- 使用 HTTPS，单双向认证，HTTPDNS ，直连等
</details>

###  TCP的握手过程？为什么进行三次握手，四次挥手

<details>
<summary> 参考内容 </summary>

三次握手：

> 为了确认服务端和客户端双方的收发能力（解决超时问题）

* 客户端发送 SYN = 1，seq=x 给服务端
* 服务端接收发送 SYN = 1，ACK = 1，ack=x+1， seq = y 给客户端
* 客户端发送 ACK = 1，ack = y+1 ，seq = z 给服务端

四次挥手：

> 全双工模式下，二次并无真正关闭，需要四次。

* 主动方发送 FIN = 1，seq = u 给被动方；
* 被动方 ACK = 1，ack = u+1，seq = v；
* 被动方继续传输数据给主动方；
* 被动方没有更多数据了，发送 FIN = 1，ACK=1，seq = w，ack=u+1；
* 主动方 ACK = 1，seq = u + 1，ack = w +1;

</details>

### 堆和栈区的区别？谁的占用内存空间大

<details>
<summary> 参考内容 </summary>

> 堆

##### 申请方式

- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；

- 堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收；

##### 操作方式

- 栈区：操作方式类似于数据结构中的栈；

- 堆区：不同于数据结构中的堆，分配方式类似于链表。

##### 申请后系统的响应 

- 栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；

- 堆区：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 

##### 申请大小的限制

- 栈区：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

- 堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

##### 申请效率的比较

- 栈区：系统自动分配，速度较快。但程序员是无法控制的。

- 堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 

- 注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

##### 堆和栈中的存储内容

- 栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

- 堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

</details>

### 常见的对称加密和非对称加密算法有哪些

<details>
<summary> 参考内容 </summary>

#### 对称加密

对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥，作为私钥。

具体算法有：DES，3DES，TDEA，Blowfish，RC5，IDEA。常见的有：DES，AES，3DES等等。

> 优点：算法公开、计算量小、加密速度快、加密效率高。 缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。

#### 非对称加密

非对称加密指的是：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。私钥加密的信息，只有公钥才能解密。 私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。

我们常见的数字证书、加密狗即是采用非对称加密来完成安全验证的。

> 优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

主要算法：RSA、Elgamal、背包算法、Rabin、HD,ECC（椭圆曲线加密算法）。常见的有：RSA，ECC

#### 银行动态令牌

网银比较流行的时候，银行给我们发一个动态令牌。这个令牌并不使用任何对称或者非对称加密的算法，在整个银行的认证体系中，动态令牌只是一个一次性口令的产生器，它是基于时间同步方式，每隔60秒产生一个随机6位动态密码在其中运行的主要计算仅包括时间因子的计算和散列值的计算。

在用户从银行手中拿到动态口令令牌卡的时候，在令牌卡的内部已经存储了一份种子文件（即图中钥匙所代表的seed），这份种子文件在银行的服务器里保存的完全一样的一份，所以对于动态口令令牌来说，这种方式是share secret的。另外在令牌硬件上的设置中，假使有人打开了这个令牌卡，种子文件将会从令牌卡的内存上擦除（待考证）。 令牌卡中有了种子文件，并实现了TOTP算法，在预先设置的间隔时间里它就能不断产生不同的动态口令，并显示到屏幕上，而银行服务器上跟随时间做同样的计算，也会得到和令牌卡同样的口令，用作认证。 那么TOTP算法具体做了什么操作呢？在RFC6238中有详细的算法描述，这里也会做简单的叙述。

> TOTP是来自 HOTP [RFC4226] 的变形，从统筹上看，他们都是将数据文件进行散列计算，只是HOTP的因子是事件因子，TOTP将因子换成了时间因子，具体的TOTP计算公式(其中的HMAC-SHA-256也可能是 HMAC-SHA-512)： TOTP = Truncate(HMAC-SHA-256(K,T))

其中： K 为这里的种子文件内容； T 为计算出来的时间因子 公式中的 HMAC是密钥相关的哈希运算消息认证码(Hash-based Message Authentication Code)，HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。而公式中给出的哈希算法是 SHA-256，这种哈希算法目前并没有好的破解办法。 令牌卡中预先设置了要显示的口令长度，TOTP 中的 Truncate 操作剪切获得口令。 以上就是动态口令令牌卡的内部原理。

> 解答出自zhuanlan.zhihu.com/p/38307899

</details>

### MD5、Sha1、Sha256区别
<details>
<summary> 参考内容 </summary>

- 签名算法，SHA(Security Hash Algorithm) ， MD5 更高效，花费时间更少，但相对较容易**碰撞**
- SHA1 已经被攻破，所以安全性不行。

</details>


### charles抓包过程？不使用charles，4G网络如何抓包

<details>
<summary> 参考内容 </summary>

-  中间人攻击原理
	- 截获真实客户端的HTTPS请求，伪装客户端向真实服务端发送HTTPS请求
	- 接受真实服务器响应，用Charles自己的证书伪装服务端向真实客户端发送数据内容

- 4G网络如何抓包
	-  iphone安装stream
	-  mac+iphone，在mac上安装**wireshark**，这款软件很强大
	-  手机开热点，电脑连接手机热点

</details>


## 数据结构与算法

> 对于移动开发者来说，一般不会遇到非常难的算法，大多以数据结构为主，笔者列出一些必会的算法，当然有时间了可以去LeetCode上刷刷题

1. 八大排序算法
1. 栈&队列
1. 字符串处理
1. 链表
1. 二叉树相关操作
1. 深搜广搜
1. 基本的动态规划题、贪心算法、二分查找



## 链接

- [面试题系列目录](../README.md)
- **上一份**: [新浪公司iOS面试题2019年6月](19新浪公司iOS面试题2019年6月.md)
- **下一份**: [出一套iOS高级面试题J_Knight_](21出一套iOS高级面试题2018年7月.md)

## 赞赏一下旺仔(收集整理不易，且赞且珍惜)

</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18ff90e4c8344f86aa69c34065bb379a~tplv-k3u1fbpfcp-zoom-1.image" width="300" height="300">
<img src="../images/wechat.JPG" width="300" height="300">
</p>
